# 【VUE】产品需求迭代引发的血案

## 第一天

小扭正在惬意地听着音乐，抖着腿。不加班地感觉好爽啊！

正在幻想幸福生活之际，瞥见产品正迈着正步款款走来。

小扭内心一声惊呼：不好！赶忙敲起了键盘。怎奈产品已立于眼前。

产品：小哥忙不？

小扭：忙……

产品：你看你都有时间听我说话……

小扭：（怕不是个傻子吧！）

产品：帮我加个需求，好不好嘛！

小扭：不好！！！

产品：那这个需求是这样的……

小扭：（有木有在听人家说话啊喂！人家都说不好了！）

产品：我们之前的详情页底部有两个按钮“加入购物车”和“立即购买”，点击的时候进行不同的操作。现在搞活动，这个底部按钮还会有其他状态，文案也不一样！

小扭：加字段，后台也得改啊！

产品：后台小哥已经同意了！（逃跑中）拜托了！

后台：（愤怒）你不是说前端都改完了么？你个大屁眼子给我回来！

小扭只好打开之前的代码：

```html
<template>
    <div class="flex course-btn-list">
        <div class="flex-1 course-btn" :class="leftBtnClass" @click="onPutIntoCart">加入购物车</div>
        <div class="flex-1 course-btn on" @click="onBuyItNow">立即购买</div>
    </div>
</template>

<script>
export default {
    methods: {
        onAddIntoCart() {
            // 加入购物车代码
        },
        onBuyItNow() {
            // 立即购买代码
        }
    }
}
</script>
```

easy！太轻松了！

## 第二天

不久，产品过来了：“这个底部按钮还会有其他状态，有些状态只有一个按钮，并且文案也不一样！”好吧貌似这个需要改后台接口，不过后台同学也给力，很快就加了一个status字段。

他跟我说：“我给你加了一个status字段，你根据这个判断按钮状态和文案就行了！”好像听起来很简单，但是仔细一想，发现事情并不简单。

更换文案倒是小事，但点击事件会有更多，不过我们可以使用更多的dom结构来实现，然后根据不同的status来控制不同的dom隐藏显示就行了。第二版方案很快就改好了。

```html
<template>
    <div v-if="status===0" class="flex course-btn-list">
        <div class="flex-1 course-btn" :class="leftBtnClass" @click="onPutIntoCart">加入购物车</div>
        <div class="flex-1 course-btn on" @click="onBuyItNow">立即购买</div>
    </div>
    <div v-if="status===1" class="flex course-btn-list">
        <div class="flex-1 course-btn" :class="leftBtnClass">已加入购物车</div>
    </div>
    <div v-if="status===2" class="flex course-btn-list">
        <div class="flex-1 course-btn" :class="leftBtnClass">产品已失效</div>
    </div>
    <!-- more tag here -->
</template>

<script>
// 请求代码就省略了

export default {
    data() {
        return {
            status: 0
        }
    },
    mounted() {
        this.initPage()
    },
    methods: {
        initPage() {
            if (this.status === 0) {
                this.leftBtnText = '加入购物车'
            } else if (this.status === 1) {
                this.leftBtnText = '已加入购物车'
            } else if (this.status === 2) {
                this.leftBtnText = '产品已失效'
            }
            // more code here
        },
        onAddIntoCart() {
            // 加入购物车代码
        },
        onBuyItNow() {
            // 立即购买代码
        }
    }
}
</script>
```

不过之后再看这段代码，怎么看都不顺眼！

首先，dom结构会随着状态的增多而增多，现在只有三个，保不齐有十个八个呢！其次，这么多if...else真的出自一个写了三年代码的人之手么？（汗流浃背）

不行，不行，得想办法掩盖自己的罪恶，先从js代码开始。

可以替代if...else的都有什么呢？switch...case？这两个代码量没啥太大区别，只是查找方式不一样而已。

这个状态很有规律，0，1，2...这似乎让我们本能地想起了数组的索引值，并且要改的文案属性也一致。

如果我们设定一个数组的，每一项都是一个对象，那我们岂不是只用读取对象属性值就可以了么？这个想法貌似可行...

```html
<template>
    <div v-if="status===0" class="flex course-btn-list">
        <div class="flex-1 course-btn" @click="onPutIntoCart">加入购物车</div>
        <div class="flex-1 course-btn on" @click="onBuyItNow">立即购买</div>
    </div>
    <div v-if="status===1" class="flex course-btn-list">
        <div class="flex-1 course-btn">已加入购物车</div>
    </div>
    <div v-if="status===2" class="flex course-btn-list">
        <div class="flex-1 course-btn">产品已失效</div>
    </div>
    <!-- more tag here -->
</template>

<script>
// 按钮文案的配置文件
const CONFIG = [{
    leftBtnText: '加入购物车'
}, {
    leftBtnText: '已加入购物车'
}, {
    leftBtnText: '产品已失效'
}]

export default {
    data() {
        return {
            status: 0
        }
    },
    mounted() {
        this.initPage()
    },
    methods: {
        initPage() {
            // 拿到了配置
            let btnConfig = CONFIG[this.status]
            // 更新文案
            this.leftBtnText = btnConfig.leftBtnText
        },
        onAddIntoCart() {
            // 加入购物车代码
        },
        onBuyItNow() {
            // 立即购买代码
        }
    }
}
</script>
```

哇！讨厌的一大坨代码立马就不见了，取而代之的是两行清爽的代码，并且逻辑结构依旧分明。

因为是静态的配置文件，我们把CONFIG单独提出来，放在page.js里。嗯，应该很完美了！

可是上面的dom结构还是存在冗余代码。这么多状态，对应的dom结构都是一样的，那我们可不可以共用一个？

但这样就有一个问题：公用一个dom结构的话，如何配置点击事件呢？

上面我们可以看到，不同的状态我们可以获取到不同的配置文件，那我们是不是可以把点击方法也放在配置文件里呢。我们先用一个按钮的状况进行举例，我们先添加一个callback属性。

page.js

```javascript
// 按钮文案的配置文件
const CONFIG = [{
    leftBtnText: '加入购物车',
    callback: 'onAddIntoCart'
}, {
    leftBtnText: '已加入购物车'
}, {
    leftBtnText: '产品已失效'
}]
```

这样我们就可以通过配置文件拿到对应的方法名了。我们把vue文件稍微修改一下。

```html
<template>
    <div class="flex course-btn-list">
        <div class="flex-1 course-btn" @click="leftClick">{{leftBtnText}}</div>
        <div class="flex-1 course-btn on" @click="onBuyItNow">立即购买</div>
    </div>
</template>

<script>
export default {
    data() {
        return {
            status: 0
        }
    },
    computed: {
        // 拿到了配置
        btnConfig() {
            return CONFIG[this.status]
        },
        // 更新文案
        leftBtnText() {
            return this.btnConfig.leftBtnText
        },
        // 获取事件方法名
        leftBtnClick() {
            return this.btnConfig.callback
        },
        // 获取点击事件
        leftClick() {
            return this[this.leftBtnClick]
        }
    },
    mounted() {
    },
    methods: {
        onAddIntoCart() {
            // 加入购物车代码
        },
        onBuyItNow() {
            // 立即购买代码
        }
    }
}
</script>
```

到这里我们的dom结构就已经全部复用了，可以脱离v-if的控制了。

那还有两个按钮的情况呢！有了一个按钮的配置，两个按钮的配置还会复杂么？我们可以把数组中返回的单个对象改成数组，这样的话，何止两个按钮，你配置几个对象，就可以显示几个按钮。废话不多说，上代码！

page.js

```javascript
// 按钮文案的配置文件
const CONFIG = [
    [{
        text: '加入购物车',
        callback: 'onAddIntoCart'
    }, {
        text: '立即购买',
        callback: 'onBuyItNow'
    }
    // more btn config here
    ], [{
        text: '已加入购物车'
    }], [{
        text: '产品已失效'
    }]
]
```

app.vue

```html
<template>
    <div class="flex course-btn-list">
        <div class="flex-1 course-btn" @click="leftClick">{{leftBtnText}}</div>
        <div v-if="rightConfig" class="flex-1 course-btn on" @click="rightClick">{{rightBtnText}}</div>
    </div>
</template>

<script>
export default {
    data() {
        return {
            status: 0
        }
    },
    computed: {
        // 拿到了配置
        btnConfig() {
            return CONFIG[this.status]
        },
        // 左键配置文件
        leftConfig() {
            return this.btnConfig[0]
        },
        leftBtnText() {
            return this.leftConfig.text
        },
        // 获取事件方法名
        leftBtnClick() {
            return this.leftConfig.callback
        },
        // 获取点击事件
        leftClick() {
            return this[this.leftBtnClick]
        },
        /*
        * 右键配置
        */
        rightConfig() {
            return this.btnConfig[1]
        },
        rightBtnText() {
            return this.rightConfig.text
        },
        rightBtnClick() {
            return this.rightConfig.callback
        },
        rightClick() {
            return this[this.rightBtnClick]
        }
        // more btn config here
    },
    methods: {
        onAddIntoCart() {
            // 加入购物车代码
        },
        onBuyItNow() {
            // 立即购买代码
        }
    }
}
</script>
```

这样我们就实现了dom结构的复用和按键点击事件的配置。代码简洁了不少。

不过作为代码洁癖的我们，岂能就此打住？

我们看到computed的代码也多了起来，多个按钮的话，我们岂不是要写很多很多相同代码了？