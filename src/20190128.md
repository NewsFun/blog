# 追踪用户最新操作

事情的起因是这样的：一行开发坐在一起抠脚，坐等项目上线。

[](https://raw.githubusercontent.com/NewsFun/blog/dev/src/img/koujiao.gif)

对面的测试老师，偶尔点点页面。忽然，测试老师发声了：“这里有个bug……”

话音刚落，一众开发炸了锅，一个个怒不可遏地围了上来。我们的代码完美无瑕，怎么可能有 bug？肯定是你们打开的方式不对。

不过听了测试的描述，大家都陷入了沉默。这确实是一个问题，页面响应与用户操作不同，这个是万万不行滴。就像大家去吃饭，点了黄焖鸡，但是上来了一碗蛋炒饭一样，恐怕这样的饭店是开不下去的。

针对这种情况，大家展开了讨论。经过一番面红耳赤，七嘴八舌，抑扬顿挫地深入交流，问题得到和平解决。

最终给出了三种方案：

1. 添加弹层，当请求发送后弹出加载弹层，显示加载动画。这样用户无法进行其他操作，只能等待。就不存在疯狂操作的问题了。这种方法是通用方法，大多数的应用都是这种处理方式。当然，缺点也很明显，阻断了用户操作，用户只能等待，其实等于页面的所有操作都是同步的。一旦一个请求崩溃，整个应用流程就被阻断。

2. 添加loading状态，一个请求发出后，loading状态置为true。再次请求时，判断loading状态，有的话便不发送请求。这TMD跟上一个有啥区别？并且还要弹一大堆提示。

3. 不阻断用户操作，但是用全局变量记录用户最新操作，每次发请求声明一个临时变量。每次数据回来时，判断临时变量是否等于全局变量。如果是，证明是当前操作，则渲染数据，否则不渲染。

经过前端同学的“深思熟虑”之后。决定采用第三种方法。然而又遇到了第二个问题：用什么标示当前请求和用户操作？有人提议用当前筛选条件。可以把筛选条件的code码拼成标示码，然后每次筛选操作便是唯一的标示码了。然而，如果用户多次点击同一次筛选条件，便不能区分两次请求了。问题依然存在。

因此还需要这个标示码具有时间唯一性。想到这里，前端同学眉头一皱，计上心来。时间唯一性，那不就是时间戳么？最终决定发送请求时加上时间戳。

有了解决方案以后，气氛忽然缓和了许多。大家纷纷放下手中的屠龙刀，开始整理自己的代码。

其实，任谁都知道第一种方案相对好点儿。可是弹窗花费时间更长。
